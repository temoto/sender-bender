// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bendertalk.proto

/*
	Package bendertalk is a generated protocol buffer package.

	It is generated from these files:
		bendertalk.proto

	It has these top-level messages:
		Request
		Response
		SMSMessage
		SMPPMessage
*/
package bendertalk

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RequestType int32

const (
	Ping    RequestType = 0
	SendSMS RequestType = 1
)

var RequestType_name = map[int32]string{
	0: "Ping",
	1: "SendSMS",
}
var RequestType_value = map[string]int32{
	"Ping":    0,
	"SendSMS": 1,
}

func (RequestType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{0} }

type ResponseStatus int32

const (
	// Error codes:
	// 1-99: protocol level errors
	// 100-199: sendsms
	StatusOk       ResponseStatus = 0
	StatusError    ResponseStatus = 1
	InvalidVersion ResponseStatus = 2
	InvalidType    ResponseStatus = 3
	InvalidId      ResponseStatus = 4
	// SendSMS 100-199
	InvalidNumber    ResponseStatus = 100
	InvalidText      ResponseStatus = 101
	InvalidSignature ResponseStatus = 102
	InvalidTime      ResponseStatus = 103
)

var ResponseStatus_name = map[int32]string{
	0:   "StatusOk",
	1:   "StatusError",
	2:   "InvalidVersion",
	3:   "InvalidType",
	4:   "InvalidId",
	100: "InvalidNumber",
	101: "InvalidText",
	102: "InvalidSignature",
	103: "InvalidTime",
}
var ResponseStatus_value = map[string]int32{
	"StatusOk":         0,
	"StatusError":      1,
	"InvalidVersion":   2,
	"InvalidType":      3,
	"InvalidId":        4,
	"InvalidNumber":    100,
	"InvalidText":      101,
	"InvalidSignature": 102,
	"InvalidTime":      103,
}

func (ResponseStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{1} }

type SMPPMessageState int32

const (
	SMPPMessageStateAttempt       SMPPMessageState = 0
	SMPPMessageStateEnroute       SMPPMessageState = 1
	SMPPMessageStateDelivered     SMPPMessageState = 2
	SMPPMessageStateExpired       SMPPMessageState = 3
	SMPPMessageStateDeleted       SMPPMessageState = 4
	SMPPMessageStateUndeliverable SMPPMessageState = 5
	SMPPMessageStateAccepted      SMPPMessageState = 6
	SMPPMessageStateUnknown       SMPPMessageState = 7
	SMPPMessageStateRejected      SMPPMessageState = 8
	SMPPMessageStateSkipped       SMPPMessageState = 9
)

var SMPPMessageState_name = map[int32]string{
	0: "SMPPMessageStateAttempt",
	1: "SMPPMessageStateEnroute",
	2: "SMPPMessageStateDelivered",
	3: "SMPPMessageStateExpired",
	4: "SMPPMessageStateDeleted",
	5: "SMPPMessageStateUndeliverable",
	6: "SMPPMessageStateAccepted",
	7: "SMPPMessageStateUnknown",
	8: "SMPPMessageStateRejected",
	9: "SMPPMessageStateSkipped",
}
var SMPPMessageState_value = map[string]int32{
	"SMPPMessageStateAttempt":       0,
	"SMPPMessageStateEnroute":       1,
	"SMPPMessageStateDelivered":     2,
	"SMPPMessageStateExpired":       3,
	"SMPPMessageStateDeleted":       4,
	"SMPPMessageStateUndeliverable": 5,
	"SMPPMessageStateAccepted":      6,
	"SMPPMessageStateUnknown":       7,
	"SMPPMessageStateRejected":      8,
	"SMPPMessageStateSkipped":       9,
}

func (SMPPMessageState) EnumDescriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{2} }

type SMPPMessagingMode int32

const (
	SMPPMessagingModeDefault      SMPPMessagingMode = 0
	SMPPMessagingModeDatagram     SMPPMessagingMode = 1
	SMPPMessagingModeTransaction  SMPPMessagingMode = 2
	SMPPMessagingModeStoreForward SMPPMessagingMode = 3
)

var SMPPMessagingMode_name = map[int32]string{
	0: "SMPPMessagingModeDefault",
	1: "SMPPMessagingModeDatagram",
	2: "SMPPMessagingModeTransaction",
	3: "SMPPMessagingModeStoreForward",
}
var SMPPMessagingMode_value = map[string]int32{
	"SMPPMessagingModeDefault":      0,
	"SMPPMessagingModeDatagram":     1,
	"SMPPMessagingModeTransaction":  2,
	"SMPPMessagingModeStoreForward": 3,
}

func (SMPPMessagingMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{3} }

type Request struct {
	Version     uint32      `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Id          uint64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Type        RequestType `protobuf:"varint,3,opt,name=type,proto3,enum=bendertalk.RequestType" json:"type,omitempty"`
	AccessToken string      `protobuf:"bytes,4,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	Tenant      string      `protobuf:"bytes,5,opt,name=tenant,proto3" json:"tenant,omitempty"`
	Debug       bool        `protobuf:"varint,6,opt,name=debug,proto3" json:"debug,omitempty"`
	DryRun      bool        `protobuf:"varint,7,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Ping is empty
	Sms []*SMSMessage `protobuf:"bytes,51,rep,name=sms" json:"sms,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{0} }

type Response struct {
	Version   uint32         `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	RequestId uint64         `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Status    ResponseStatus `protobuf:"varint,3,opt,name=status,proto3,enum=bendertalk.ResponseStatus" json:"status,omitempty"`
	Error     string         `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	Debug     []string       `protobuf:"bytes,5,rep,name=debug" json:"debug,omitempty"`
	Sms       []*SMSMessage  `protobuf:"bytes,51,rep,name=sms" json:"sms,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{1} }

type SMSMessage struct {
	// input: from, to, text, mode, schedule_unix, validity_unix, delivery_hours_utc
	// output: id, state, network_error_code
	Id                    string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From                  string            `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                    string            `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Text                  string            `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	Mode                  SMPPMessagingMode `protobuf:"varint,5,opt,name=mode,proto3,enum=bendertalk.SMPPMessagingMode" json:"mode,omitempty"`
	ValidityUnix          int64             `protobuf:"varint,6,opt,name=validity_unix,json=validityUnix,proto3" json:"validity_unix,omitempty"`
	ScheduleUnix          int64             `protobuf:"varint,7,opt,name=schedule_unix,json=scheduleUnix,proto3" json:"schedule_unix,omitempty"`
	State                 SMPPMessageState  `protobuf:"varint,8,opt,name=state,proto3,enum=bendertalk.SMPPMessageState" json:"state,omitempty"`
	NetworkErrorCode      uint32            `protobuf:"varint,9,opt,name=network_error_code,json=networkErrorCode,proto3" json:"network_error_code,omitempty"`
	DeliveryHoursUtc      uint32            `protobuf:"varint,16,opt,name=delivery_hours_utc,json=deliveryHoursUtc,proto3" json:"delivery_hours_utc,omitempty"`
	ApplicationTag        string            `protobuf:"bytes,17,opt,name=application_tag,json=applicationTag,proto3" json:"application_tag,omitempty"`
	DeliveryCheckUpstream string            `protobuf:"bytes,18,opt,name=delivery_check_upstream,json=deliveryCheckUpstream,proto3" json:"delivery_check_upstream,omitempty"`
}

func (m *SMSMessage) Reset()                    { *m = SMSMessage{} }
func (*SMSMessage) ProtoMessage()               {}
func (*SMSMessage) Descriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{2} }

type SMPPMessage struct {
	// SMPP send mandatory
	SrcAddr              string `protobuf:"bytes,1,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	DestAddr             string `protobuf:"bytes,2,opt,name=dest_addr,json=destAddr,proto3" json:"dest_addr,omitempty"`
	ShortText            []byte `protobuf:"bytes,3,opt,name=short_text,json=shortText,proto3" json:"short_text,omitempty"`
	EsmClass             uint32 `protobuf:"varint,5,opt,name=esm_class,json=esmClass,proto3" json:"esm_class,omitempty"`
	DataCoding           uint32 `protobuf:"varint,6,opt,name=data_coding,json=dataCoding,proto3" json:"data_coding,omitempty"`
	RegisteredDelivery   uint32 `protobuf:"varint,7,opt,name=registered_delivery,json=registeredDelivery,proto3" json:"registered_delivery,omitempty"`
	ValidityPeriod       string `protobuf:"bytes,8,opt,name=validity_period,json=validityPeriod,proto3" json:"validity_period,omitempty"`
	ServiceType          string `protobuf:"bytes,16,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	SrcAddrTon           uint32 `protobuf:"varint,17,opt,name=src_addr_ton,json=srcAddrTon,proto3" json:"src_addr_ton,omitempty"`
	SrcAddrNpi           uint32 `protobuf:"varint,18,opt,name=src_addr_npi,json=srcAddrNpi,proto3" json:"src_addr_npi,omitempty"`
	DestAddrTon          uint32 `protobuf:"varint,19,opt,name=dest_addr_ton,json=destAddrTon,proto3" json:"dest_addr_ton,omitempty"`
	DestAddrNpi          uint32 `protobuf:"varint,20,opt,name=dest_addr_npi,json=destAddrNpi,proto3" json:"dest_addr_npi,omitempty"`
	ProtocolId           uint32 `protobuf:"varint,21,opt,name=protocol_id,json=protocolId,proto3" json:"protocol_id,omitempty"`
	PriorityFlag         uint32 `protobuf:"varint,22,opt,name=priority_flag,json=priorityFlag,proto3" json:"priority_flag,omitempty"`
	ReplaceIfPresentFlag uint32 `protobuf:"varint,25,opt,name=replace_if_present_flag,json=replaceIfPresentFlag,proto3" json:"replace_if_present_flag,omitempty"`
	// SMPP send TLV
	SarMsgRefNum         uint32 `protobuf:"varint,40,opt,name=sar_msg_ref_num,json=sarMsgRefNum,proto3" json:"sar_msg_ref_num,omitempty"`
	SarTotalSegments     uint32 `protobuf:"varint,41,opt,name=sar_total_segments,json=sarTotalSegments,proto3" json:"sar_total_segments,omitempty"`
	SarSegmentSeqnum     uint32 `protobuf:"varint,42,opt,name=sar_segment_seqnum,json=sarSegmentSeqnum,proto3" json:"sar_segment_seqnum,omitempty"`
	MoreMessagesToSend   bool   `protobuf:"varint,43,opt,name=more_messages_to_send,json=moreMessagesToSend,proto3" json:"more_messages_to_send,omitempty"`
	PayloadType          uint32 `protobuf:"varint,44,opt,name=payload_type,json=payloadType,proto3" json:"payload_type,omitempty"`
	MessagePayload       []byte `protobuf:"bytes,45,opt,name=message_payload,json=messagePayload,proto3" json:"message_payload,omitempty"`
	UserMessageReference uint64 `protobuf:"varint,46,opt,name=user_message_reference,json=userMessageReference,proto3" json:"user_message_reference,omitempty"`
	// SMPP response TLV
	NetworkErrorCode   uint32 `protobuf:"varint,60,opt,name=network_error_code,json=networkErrorCode,proto3" json:"network_error_code,omitempty"`
	ReceiptedMessageId string `protobuf:"bytes,62,opt,name=receipted_message_id,json=receiptedMessageId,proto3" json:"receipted_message_id,omitempty"`
}

func (m *SMPPMessage) Reset()                    { *m = SMPPMessage{} }
func (*SMPPMessage) ProtoMessage()               {}
func (*SMPPMessage) Descriptor() ([]byte, []int) { return fileDescriptorBendertalk, []int{3} }

func init() {
	proto.RegisterType((*Request)(nil), "bendertalk.Request")
	proto.RegisterType((*Response)(nil), "bendertalk.Response")
	proto.RegisterType((*SMSMessage)(nil), "bendertalk.SMSMessage")
	proto.RegisterType((*SMPPMessage)(nil), "bendertalk.SMPPMessage")
	proto.RegisterEnum("bendertalk.RequestType", RequestType_name, RequestType_value)
	proto.RegisterEnum("bendertalk.ResponseStatus", ResponseStatus_name, ResponseStatus_value)
	proto.RegisterEnum("bendertalk.SMPPMessageState", SMPPMessageState_name, SMPPMessageState_value)
	proto.RegisterEnum("bendertalk.SMPPMessagingMode", SMPPMessagingMode_name, SMPPMessagingMode_value)
}
func (x RequestType) String() string {
	s, ok := RequestType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ResponseStatus) String() string {
	s, ok := ResponseStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SMPPMessageState) String() string {
	s, ok := SMPPMessageState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SMPPMessagingMode) String() string {
	s, ok := SMPPMessagingMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Request) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Request")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Request but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Request but is not nil && this == nil")
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.AccessToken != that1.AccessToken {
		return fmt.Errorf("AccessToken this(%v) Not Equal that(%v)", this.AccessToken, that1.AccessToken)
	}
	if this.Tenant != that1.Tenant {
		return fmt.Errorf("Tenant this(%v) Not Equal that(%v)", this.Tenant, that1.Tenant)
	}
	if this.Debug != that1.Debug {
		return fmt.Errorf("Debug this(%v) Not Equal that(%v)", this.Debug, that1.Debug)
	}
	if this.DryRun != that1.DryRun {
		return fmt.Errorf("DryRun this(%v) Not Equal that(%v)", this.DryRun, that1.DryRun)
	}
	if len(this.Sms) != len(that1.Sms) {
		return fmt.Errorf("Sms this(%v) Not Equal that(%v)", len(this.Sms), len(that1.Sms))
	}
	for i := range this.Sms {
		if !this.Sms[i].Equal(that1.Sms[i]) {
			return fmt.Errorf("Sms this[%v](%v) Not Equal that[%v](%v)", i, this.Sms[i], i, that1.Sms[i])
		}
	}
	return nil
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Debug != that1.Debug {
		return false
	}
	if this.DryRun != that1.DryRun {
		return false
	}
	if len(this.Sms) != len(that1.Sms) {
		return false
	}
	for i := range this.Sms {
		if !this.Sms[i].Equal(that1.Sms[i]) {
			return false
		}
	}
	return true
}
func (this *Response) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Response")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Response but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Response but is not nil && this == nil")
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.RequestId != that1.RequestId {
		return fmt.Errorf("RequestId this(%v) Not Equal that(%v)", this.RequestId, that1.RequestId)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Error != that1.Error {
		return fmt.Errorf("Error this(%v) Not Equal that(%v)", this.Error, that1.Error)
	}
	if len(this.Debug) != len(that1.Debug) {
		return fmt.Errorf("Debug this(%v) Not Equal that(%v)", len(this.Debug), len(that1.Debug))
	}
	for i := range this.Debug {
		if this.Debug[i] != that1.Debug[i] {
			return fmt.Errorf("Debug this[%v](%v) Not Equal that[%v](%v)", i, this.Debug[i], i, that1.Debug[i])
		}
	}
	if len(this.Sms) != len(that1.Sms) {
		return fmt.Errorf("Sms this(%v) Not Equal that(%v)", len(this.Sms), len(that1.Sms))
	}
	for i := range this.Sms {
		if !this.Sms[i].Equal(that1.Sms[i]) {
			return fmt.Errorf("Sms this[%v](%v) Not Equal that[%v](%v)", i, this.Sms[i], i, that1.Sms[i])
		}
	}
	return nil
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.RequestId != that1.RequestId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if len(this.Debug) != len(that1.Debug) {
		return false
	}
	for i := range this.Debug {
		if this.Debug[i] != that1.Debug[i] {
			return false
		}
	}
	if len(this.Sms) != len(that1.Sms) {
		return false
	}
	for i := range this.Sms {
		if !this.Sms[i].Equal(that1.Sms[i]) {
			return false
		}
	}
	return true
}
func (this *SMSMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SMSMessage)
	if !ok {
		that2, ok := that.(SMSMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SMSMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SMSMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SMSMessage but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.From != that1.From {
		return fmt.Errorf("From this(%v) Not Equal that(%v)", this.From, that1.From)
	}
	if this.To != that1.To {
		return fmt.Errorf("To this(%v) Not Equal that(%v)", this.To, that1.To)
	}
	if this.Text != that1.Text {
		return fmt.Errorf("Text this(%v) Not Equal that(%v)", this.Text, that1.Text)
	}
	if this.Mode != that1.Mode {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	if this.ValidityUnix != that1.ValidityUnix {
		return fmt.Errorf("ValidityUnix this(%v) Not Equal that(%v)", this.ValidityUnix, that1.ValidityUnix)
	}
	if this.ScheduleUnix != that1.ScheduleUnix {
		return fmt.Errorf("ScheduleUnix this(%v) Not Equal that(%v)", this.ScheduleUnix, that1.ScheduleUnix)
	}
	if this.State != that1.State {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if this.NetworkErrorCode != that1.NetworkErrorCode {
		return fmt.Errorf("NetworkErrorCode this(%v) Not Equal that(%v)", this.NetworkErrorCode, that1.NetworkErrorCode)
	}
	if this.DeliveryHoursUtc != that1.DeliveryHoursUtc {
		return fmt.Errorf("DeliveryHoursUtc this(%v) Not Equal that(%v)", this.DeliveryHoursUtc, that1.DeliveryHoursUtc)
	}
	if this.ApplicationTag != that1.ApplicationTag {
		return fmt.Errorf("ApplicationTag this(%v) Not Equal that(%v)", this.ApplicationTag, that1.ApplicationTag)
	}
	if this.DeliveryCheckUpstream != that1.DeliveryCheckUpstream {
		return fmt.Errorf("DeliveryCheckUpstream this(%v) Not Equal that(%v)", this.DeliveryCheckUpstream, that1.DeliveryCheckUpstream)
	}
	return nil
}
func (this *SMSMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SMSMessage)
	if !ok {
		that2, ok := that.(SMSMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.From != that1.From {
		return false
	}
	if this.To != that1.To {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.ValidityUnix != that1.ValidityUnix {
		return false
	}
	if this.ScheduleUnix != that1.ScheduleUnix {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.NetworkErrorCode != that1.NetworkErrorCode {
		return false
	}
	if this.DeliveryHoursUtc != that1.DeliveryHoursUtc {
		return false
	}
	if this.ApplicationTag != that1.ApplicationTag {
		return false
	}
	if this.DeliveryCheckUpstream != that1.DeliveryCheckUpstream {
		return false
	}
	return true
}
func (this *SMPPMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SMPPMessage)
	if !ok {
		that2, ok := that.(SMPPMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SMPPMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SMPPMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SMPPMessage but is not nil && this == nil")
	}
	if this.SrcAddr != that1.SrcAddr {
		return fmt.Errorf("SrcAddr this(%v) Not Equal that(%v)", this.SrcAddr, that1.SrcAddr)
	}
	if this.DestAddr != that1.DestAddr {
		return fmt.Errorf("DestAddr this(%v) Not Equal that(%v)", this.DestAddr, that1.DestAddr)
	}
	if !bytes.Equal(this.ShortText, that1.ShortText) {
		return fmt.Errorf("ShortText this(%v) Not Equal that(%v)", this.ShortText, that1.ShortText)
	}
	if this.EsmClass != that1.EsmClass {
		return fmt.Errorf("EsmClass this(%v) Not Equal that(%v)", this.EsmClass, that1.EsmClass)
	}
	if this.DataCoding != that1.DataCoding {
		return fmt.Errorf("DataCoding this(%v) Not Equal that(%v)", this.DataCoding, that1.DataCoding)
	}
	if this.RegisteredDelivery != that1.RegisteredDelivery {
		return fmt.Errorf("RegisteredDelivery this(%v) Not Equal that(%v)", this.RegisteredDelivery, that1.RegisteredDelivery)
	}
	if this.ValidityPeriod != that1.ValidityPeriod {
		return fmt.Errorf("ValidityPeriod this(%v) Not Equal that(%v)", this.ValidityPeriod, that1.ValidityPeriod)
	}
	if this.ServiceType != that1.ServiceType {
		return fmt.Errorf("ServiceType this(%v) Not Equal that(%v)", this.ServiceType, that1.ServiceType)
	}
	if this.SrcAddrTon != that1.SrcAddrTon {
		return fmt.Errorf("SrcAddrTon this(%v) Not Equal that(%v)", this.SrcAddrTon, that1.SrcAddrTon)
	}
	if this.SrcAddrNpi != that1.SrcAddrNpi {
		return fmt.Errorf("SrcAddrNpi this(%v) Not Equal that(%v)", this.SrcAddrNpi, that1.SrcAddrNpi)
	}
	if this.DestAddrTon != that1.DestAddrTon {
		return fmt.Errorf("DestAddrTon this(%v) Not Equal that(%v)", this.DestAddrTon, that1.DestAddrTon)
	}
	if this.DestAddrNpi != that1.DestAddrNpi {
		return fmt.Errorf("DestAddrNpi this(%v) Not Equal that(%v)", this.DestAddrNpi, that1.DestAddrNpi)
	}
	if this.ProtocolId != that1.ProtocolId {
		return fmt.Errorf("ProtocolId this(%v) Not Equal that(%v)", this.ProtocolId, that1.ProtocolId)
	}
	if this.PriorityFlag != that1.PriorityFlag {
		return fmt.Errorf("PriorityFlag this(%v) Not Equal that(%v)", this.PriorityFlag, that1.PriorityFlag)
	}
	if this.ReplaceIfPresentFlag != that1.ReplaceIfPresentFlag {
		return fmt.Errorf("ReplaceIfPresentFlag this(%v) Not Equal that(%v)", this.ReplaceIfPresentFlag, that1.ReplaceIfPresentFlag)
	}
	if this.SarMsgRefNum != that1.SarMsgRefNum {
		return fmt.Errorf("SarMsgRefNum this(%v) Not Equal that(%v)", this.SarMsgRefNum, that1.SarMsgRefNum)
	}
	if this.SarTotalSegments != that1.SarTotalSegments {
		return fmt.Errorf("SarTotalSegments this(%v) Not Equal that(%v)", this.SarTotalSegments, that1.SarTotalSegments)
	}
	if this.SarSegmentSeqnum != that1.SarSegmentSeqnum {
		return fmt.Errorf("SarSegmentSeqnum this(%v) Not Equal that(%v)", this.SarSegmentSeqnum, that1.SarSegmentSeqnum)
	}
	if this.MoreMessagesToSend != that1.MoreMessagesToSend {
		return fmt.Errorf("MoreMessagesToSend this(%v) Not Equal that(%v)", this.MoreMessagesToSend, that1.MoreMessagesToSend)
	}
	if this.PayloadType != that1.PayloadType {
		return fmt.Errorf("PayloadType this(%v) Not Equal that(%v)", this.PayloadType, that1.PayloadType)
	}
	if !bytes.Equal(this.MessagePayload, that1.MessagePayload) {
		return fmt.Errorf("MessagePayload this(%v) Not Equal that(%v)", this.MessagePayload, that1.MessagePayload)
	}
	if this.UserMessageReference != that1.UserMessageReference {
		return fmt.Errorf("UserMessageReference this(%v) Not Equal that(%v)", this.UserMessageReference, that1.UserMessageReference)
	}
	if this.NetworkErrorCode != that1.NetworkErrorCode {
		return fmt.Errorf("NetworkErrorCode this(%v) Not Equal that(%v)", this.NetworkErrorCode, that1.NetworkErrorCode)
	}
	if this.ReceiptedMessageId != that1.ReceiptedMessageId {
		return fmt.Errorf("ReceiptedMessageId this(%v) Not Equal that(%v)", this.ReceiptedMessageId, that1.ReceiptedMessageId)
	}
	return nil
}
func (this *SMPPMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SMPPMessage)
	if !ok {
		that2, ok := that.(SMPPMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SrcAddr != that1.SrcAddr {
		return false
	}
	if this.DestAddr != that1.DestAddr {
		return false
	}
	if !bytes.Equal(this.ShortText, that1.ShortText) {
		return false
	}
	if this.EsmClass != that1.EsmClass {
		return false
	}
	if this.DataCoding != that1.DataCoding {
		return false
	}
	if this.RegisteredDelivery != that1.RegisteredDelivery {
		return false
	}
	if this.ValidityPeriod != that1.ValidityPeriod {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	if this.SrcAddrTon != that1.SrcAddrTon {
		return false
	}
	if this.SrcAddrNpi != that1.SrcAddrNpi {
		return false
	}
	if this.DestAddrTon != that1.DestAddrTon {
		return false
	}
	if this.DestAddrNpi != that1.DestAddrNpi {
		return false
	}
	if this.ProtocolId != that1.ProtocolId {
		return false
	}
	if this.PriorityFlag != that1.PriorityFlag {
		return false
	}
	if this.ReplaceIfPresentFlag != that1.ReplaceIfPresentFlag {
		return false
	}
	if this.SarMsgRefNum != that1.SarMsgRefNum {
		return false
	}
	if this.SarTotalSegments != that1.SarTotalSegments {
		return false
	}
	if this.SarSegmentSeqnum != that1.SarSegmentSeqnum {
		return false
	}
	if this.MoreMessagesToSend != that1.MoreMessagesToSend {
		return false
	}
	if this.PayloadType != that1.PayloadType {
		return false
	}
	if !bytes.Equal(this.MessagePayload, that1.MessagePayload) {
		return false
	}
	if this.UserMessageReference != that1.UserMessageReference {
		return false
	}
	if this.NetworkErrorCode != that1.NetworkErrorCode {
		return false
	}
	if this.ReceiptedMessageId != that1.ReceiptedMessageId {
		return false
	}
	return true
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&bendertalk.Request{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Debug: "+fmt.Sprintf("%#v", this.Debug)+",\n")
	s = append(s, "DryRun: "+fmt.Sprintf("%#v", this.DryRun)+",\n")
	if this.Sms != nil {
		s = append(s, "Sms: "+fmt.Sprintf("%#v", this.Sms)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&bendertalk.Response{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "RequestId: "+fmt.Sprintf("%#v", this.RequestId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "Debug: "+fmt.Sprintf("%#v", this.Debug)+",\n")
	if this.Sms != nil {
		s = append(s, "Sms: "+fmt.Sprintf("%#v", this.Sms)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SMSMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&bendertalk.SMSMessage{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "ValidityUnix: "+fmt.Sprintf("%#v", this.ValidityUnix)+",\n")
	s = append(s, "ScheduleUnix: "+fmt.Sprintf("%#v", this.ScheduleUnix)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "NetworkErrorCode: "+fmt.Sprintf("%#v", this.NetworkErrorCode)+",\n")
	s = append(s, "DeliveryHoursUtc: "+fmt.Sprintf("%#v", this.DeliveryHoursUtc)+",\n")
	s = append(s, "ApplicationTag: "+fmt.Sprintf("%#v", this.ApplicationTag)+",\n")
	s = append(s, "DeliveryCheckUpstream: "+fmt.Sprintf("%#v", this.DeliveryCheckUpstream)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SMPPMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 28)
	s = append(s, "&bendertalk.SMPPMessage{")
	s = append(s, "SrcAddr: "+fmt.Sprintf("%#v", this.SrcAddr)+",\n")
	s = append(s, "DestAddr: "+fmt.Sprintf("%#v", this.DestAddr)+",\n")
	s = append(s, "ShortText: "+fmt.Sprintf("%#v", this.ShortText)+",\n")
	s = append(s, "EsmClass: "+fmt.Sprintf("%#v", this.EsmClass)+",\n")
	s = append(s, "DataCoding: "+fmt.Sprintf("%#v", this.DataCoding)+",\n")
	s = append(s, "RegisteredDelivery: "+fmt.Sprintf("%#v", this.RegisteredDelivery)+",\n")
	s = append(s, "ValidityPeriod: "+fmt.Sprintf("%#v", this.ValidityPeriod)+",\n")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "SrcAddrTon: "+fmt.Sprintf("%#v", this.SrcAddrTon)+",\n")
	s = append(s, "SrcAddrNpi: "+fmt.Sprintf("%#v", this.SrcAddrNpi)+",\n")
	s = append(s, "DestAddrTon: "+fmt.Sprintf("%#v", this.DestAddrTon)+",\n")
	s = append(s, "DestAddrNpi: "+fmt.Sprintf("%#v", this.DestAddrNpi)+",\n")
	s = append(s, "ProtocolId: "+fmt.Sprintf("%#v", this.ProtocolId)+",\n")
	s = append(s, "PriorityFlag: "+fmt.Sprintf("%#v", this.PriorityFlag)+",\n")
	s = append(s, "ReplaceIfPresentFlag: "+fmt.Sprintf("%#v", this.ReplaceIfPresentFlag)+",\n")
	s = append(s, "SarMsgRefNum: "+fmt.Sprintf("%#v", this.SarMsgRefNum)+",\n")
	s = append(s, "SarTotalSegments: "+fmt.Sprintf("%#v", this.SarTotalSegments)+",\n")
	s = append(s, "SarSegmentSeqnum: "+fmt.Sprintf("%#v", this.SarSegmentSeqnum)+",\n")
	s = append(s, "MoreMessagesToSend: "+fmt.Sprintf("%#v", this.MoreMessagesToSend)+",\n")
	s = append(s, "PayloadType: "+fmt.Sprintf("%#v", this.PayloadType)+",\n")
	s = append(s, "MessagePayload: "+fmt.Sprintf("%#v", this.MessagePayload)+",\n")
	s = append(s, "UserMessageReference: "+fmt.Sprintf("%#v", this.UserMessageReference)+",\n")
	s = append(s, "NetworkErrorCode: "+fmt.Sprintf("%#v", this.NetworkErrorCode)+",\n")
	s = append(s, "ReceiptedMessageId: "+fmt.Sprintf("%#v", this.ReceiptedMessageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBendertalk(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Version))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Type))
	}
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if m.Debug {
		dAtA[i] = 0x30
		i++
		if m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DryRun {
		dAtA[i] = 0x38
		i++
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Sms) > 0 {
		for _, msg := range m.Sms {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintBendertalk(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Version))
	}
	if m.RequestId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.RequestId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Status))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Debug) > 0 {
		for _, s := range m.Debug {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sms) > 0 {
		for _, msg := range m.Sms {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintBendertalk(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SMSMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMSMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Mode != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.Mode))
	}
	if m.ValidityUnix != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.ValidityUnix))
	}
	if m.ScheduleUnix != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.ScheduleUnix))
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.State))
	}
	if m.NetworkErrorCode != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.NetworkErrorCode))
	}
	if m.DeliveryHoursUtc != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.DeliveryHoursUtc))
	}
	if len(m.ApplicationTag) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.ApplicationTag)))
		i += copy(dAtA[i:], m.ApplicationTag)
	}
	if len(m.DeliveryCheckUpstream) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.DeliveryCheckUpstream)))
		i += copy(dAtA[i:], m.DeliveryCheckUpstream)
	}
	return i, nil
}

func (m *SMPPMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMPPMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SrcAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.SrcAddr)))
		i += copy(dAtA[i:], m.SrcAddr)
	}
	if len(m.DestAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.DestAddr)))
		i += copy(dAtA[i:], m.DestAddr)
	}
	if len(m.ShortText) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.ShortText)))
		i += copy(dAtA[i:], m.ShortText)
	}
	if m.EsmClass != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.EsmClass))
	}
	if m.DataCoding != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.DataCoding))
	}
	if m.RegisteredDelivery != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.RegisteredDelivery))
	}
	if len(m.ValidityPeriod) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.ValidityPeriod)))
		i += copy(dAtA[i:], m.ValidityPeriod)
	}
	if len(m.ServiceType) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.ServiceType)))
		i += copy(dAtA[i:], m.ServiceType)
	}
	if m.SrcAddrTon != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.SrcAddrTon))
	}
	if m.SrcAddrNpi != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.SrcAddrNpi))
	}
	if m.DestAddrTon != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.DestAddrTon))
	}
	if m.DestAddrNpi != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.DestAddrNpi))
	}
	if m.ProtocolId != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.ProtocolId))
	}
	if m.PriorityFlag != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.PriorityFlag))
	}
	if m.ReplaceIfPresentFlag != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.ReplaceIfPresentFlag))
	}
	if m.SarMsgRefNum != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.SarMsgRefNum))
	}
	if m.SarTotalSegments != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.SarTotalSegments))
	}
	if m.SarSegmentSeqnum != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.SarSegmentSeqnum))
	}
	if m.MoreMessagesToSend {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		if m.MoreMessagesToSend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PayloadType != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.PayloadType))
	}
	if len(m.MessagePayload) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.MessagePayload)))
		i += copy(dAtA[i:], m.MessagePayload)
	}
	if m.UserMessageReference != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.UserMessageReference))
	}
	if m.NetworkErrorCode != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(m.NetworkErrorCode))
	}
	if len(m.ReceiptedMessageId) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintBendertalk(dAtA, i, uint64(len(m.ReceiptedMessageId)))
		i += copy(dAtA[i:], m.ReceiptedMessageId)
	}
	return i, nil
}

func encodeVarintBendertalk(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedRequest(r randyBendertalk, easy bool) *Request {
	this := &Request{}
	this.Version = uint32(r.Uint32())
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = RequestType([]int32{0, 1}[r.Intn(2)])
	this.AccessToken = string(randStringBendertalk(r))
	this.Tenant = string(randStringBendertalk(r))
	this.Debug = bool(bool(r.Intn(2) == 0))
	this.DryRun = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Sms = make([]*SMSMessage, v1)
		for i := 0; i < v1; i++ {
			this.Sms[i] = NewPopulatedSMSMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResponse(r randyBendertalk, easy bool) *Response {
	this := &Response{}
	this.Version = uint32(r.Uint32())
	this.RequestId = uint64(uint64(r.Uint32()))
	this.Status = ResponseStatus([]int32{0, 1, 2, 3, 4, 100, 101, 102, 103}[r.Intn(9)])
	this.Error = string(randStringBendertalk(r))
	v2 := r.Intn(10)
	this.Debug = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.Debug[i] = string(randStringBendertalk(r))
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Sms = make([]*SMSMessage, v3)
		for i := 0; i < v3; i++ {
			this.Sms[i] = NewPopulatedSMSMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSMSMessage(r randyBendertalk, easy bool) *SMSMessage {
	this := &SMSMessage{}
	this.Id = string(randStringBendertalk(r))
	this.From = string(randStringBendertalk(r))
	this.To = string(randStringBendertalk(r))
	this.Text = string(randStringBendertalk(r))
	this.Mode = SMPPMessagingMode([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.ValidityUnix = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValidityUnix *= -1
	}
	this.ScheduleUnix = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ScheduleUnix *= -1
	}
	this.State = SMPPMessageState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	this.NetworkErrorCode = uint32(r.Uint32())
	this.DeliveryHoursUtc = uint32(r.Uint32())
	this.ApplicationTag = string(randStringBendertalk(r))
	this.DeliveryCheckUpstream = string(randStringBendertalk(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSMPPMessage(r randyBendertalk, easy bool) *SMPPMessage {
	this := &SMPPMessage{}
	this.SrcAddr = string(randStringBendertalk(r))
	this.DestAddr = string(randStringBendertalk(r))
	v4 := r.Intn(100)
	this.ShortText = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.ShortText[i] = byte(r.Intn(256))
	}
	this.EsmClass = uint32(r.Uint32())
	this.DataCoding = uint32(r.Uint32())
	this.RegisteredDelivery = uint32(r.Uint32())
	this.ValidityPeriod = string(randStringBendertalk(r))
	this.ServiceType = string(randStringBendertalk(r))
	this.SrcAddrTon = uint32(r.Uint32())
	this.SrcAddrNpi = uint32(r.Uint32())
	this.DestAddrTon = uint32(r.Uint32())
	this.DestAddrNpi = uint32(r.Uint32())
	this.ProtocolId = uint32(r.Uint32())
	this.PriorityFlag = uint32(r.Uint32())
	this.ReplaceIfPresentFlag = uint32(r.Uint32())
	this.SarMsgRefNum = uint32(r.Uint32())
	this.SarTotalSegments = uint32(r.Uint32())
	this.SarSegmentSeqnum = uint32(r.Uint32())
	this.MoreMessagesToSend = bool(bool(r.Intn(2) == 0))
	this.PayloadType = uint32(r.Uint32())
	v5 := r.Intn(100)
	this.MessagePayload = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.MessagePayload[i] = byte(r.Intn(256))
	}
	this.UserMessageReference = uint64(uint64(r.Uint32()))
	this.NetworkErrorCode = uint32(r.Uint32())
	this.ReceiptedMessageId = string(randStringBendertalk(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyBendertalk interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneBendertalk(r randyBendertalk) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringBendertalk(r randyBendertalk) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneBendertalk(r)
	}
	return string(tmps)
}
func randUnrecognizedBendertalk(r randyBendertalk, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldBendertalk(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldBendertalk(dAtA []byte, r randyBendertalk, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateBendertalk(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateBendertalk(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Request) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBendertalk(uint64(m.Version))
	}
	if m.Id != 0 {
		n += 1 + sovBendertalk(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovBendertalk(uint64(m.Type))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	if m.Debug {
		n += 2
	}
	if m.DryRun {
		n += 2
	}
	if len(m.Sms) > 0 {
		for _, e := range m.Sms {
			l = e.Size()
			n += 2 + l + sovBendertalk(uint64(l))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBendertalk(uint64(m.Version))
	}
	if m.RequestId != 0 {
		n += 1 + sovBendertalk(uint64(m.RequestId))
	}
	if m.Status != 0 {
		n += 1 + sovBendertalk(uint64(m.Status))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	if len(m.Debug) > 0 {
		for _, s := range m.Debug {
			l = len(s)
			n += 1 + l + sovBendertalk(uint64(l))
		}
	}
	if len(m.Sms) > 0 {
		for _, e := range m.Sms {
			l = e.Size()
			n += 2 + l + sovBendertalk(uint64(l))
		}
	}
	return n
}

func (m *SMSMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovBendertalk(uint64(m.Mode))
	}
	if m.ValidityUnix != 0 {
		n += 1 + sovBendertalk(uint64(m.ValidityUnix))
	}
	if m.ScheduleUnix != 0 {
		n += 1 + sovBendertalk(uint64(m.ScheduleUnix))
	}
	if m.State != 0 {
		n += 1 + sovBendertalk(uint64(m.State))
	}
	if m.NetworkErrorCode != 0 {
		n += 1 + sovBendertalk(uint64(m.NetworkErrorCode))
	}
	if m.DeliveryHoursUtc != 0 {
		n += 2 + sovBendertalk(uint64(m.DeliveryHoursUtc))
	}
	l = len(m.ApplicationTag)
	if l > 0 {
		n += 2 + l + sovBendertalk(uint64(l))
	}
	l = len(m.DeliveryCheckUpstream)
	if l > 0 {
		n += 2 + l + sovBendertalk(uint64(l))
	}
	return n
}

func (m *SMPPMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.SrcAddr)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.DestAddr)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.ShortText)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	if m.EsmClass != 0 {
		n += 1 + sovBendertalk(uint64(m.EsmClass))
	}
	if m.DataCoding != 0 {
		n += 1 + sovBendertalk(uint64(m.DataCoding))
	}
	if m.RegisteredDelivery != 0 {
		n += 1 + sovBendertalk(uint64(m.RegisteredDelivery))
	}
	l = len(m.ValidityPeriod)
	if l > 0 {
		n += 1 + l + sovBendertalk(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 2 + l + sovBendertalk(uint64(l))
	}
	if m.SrcAddrTon != 0 {
		n += 2 + sovBendertalk(uint64(m.SrcAddrTon))
	}
	if m.SrcAddrNpi != 0 {
		n += 2 + sovBendertalk(uint64(m.SrcAddrNpi))
	}
	if m.DestAddrTon != 0 {
		n += 2 + sovBendertalk(uint64(m.DestAddrTon))
	}
	if m.DestAddrNpi != 0 {
		n += 2 + sovBendertalk(uint64(m.DestAddrNpi))
	}
	if m.ProtocolId != 0 {
		n += 2 + sovBendertalk(uint64(m.ProtocolId))
	}
	if m.PriorityFlag != 0 {
		n += 2 + sovBendertalk(uint64(m.PriorityFlag))
	}
	if m.ReplaceIfPresentFlag != 0 {
		n += 2 + sovBendertalk(uint64(m.ReplaceIfPresentFlag))
	}
	if m.SarMsgRefNum != 0 {
		n += 2 + sovBendertalk(uint64(m.SarMsgRefNum))
	}
	if m.SarTotalSegments != 0 {
		n += 2 + sovBendertalk(uint64(m.SarTotalSegments))
	}
	if m.SarSegmentSeqnum != 0 {
		n += 2 + sovBendertalk(uint64(m.SarSegmentSeqnum))
	}
	if m.MoreMessagesToSend {
		n += 3
	}
	if m.PayloadType != 0 {
		n += 2 + sovBendertalk(uint64(m.PayloadType))
	}
	l = len(m.MessagePayload)
	if l > 0 {
		n += 2 + l + sovBendertalk(uint64(l))
	}
	if m.UserMessageReference != 0 {
		n += 2 + sovBendertalk(uint64(m.UserMessageReference))
	}
	if m.NetworkErrorCode != 0 {
		n += 2 + sovBendertalk(uint64(m.NetworkErrorCode))
	}
	l = len(m.ReceiptedMessageId)
	if l > 0 {
		n += 2 + l + sovBendertalk(uint64(l))
	}
	return n
}

func sovBendertalk(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBendertalk(x uint64) (n int) {
	return sovBendertalk(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Debug:` + fmt.Sprintf("%v", this.Debug) + `,`,
		`DryRun:` + fmt.Sprintf("%v", this.DryRun) + `,`,
		`Sms:` + strings.Replace(fmt.Sprintf("%v", this.Sms), "SMSMessage", "SMSMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`RequestId:` + fmt.Sprintf("%v", this.RequestId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Debug:` + fmt.Sprintf("%v", this.Debug) + `,`,
		`Sms:` + strings.Replace(fmt.Sprintf("%v", this.Sms), "SMSMessage", "SMSMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SMSMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SMSMessage{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`ValidityUnix:` + fmt.Sprintf("%v", this.ValidityUnix) + `,`,
		`ScheduleUnix:` + fmt.Sprintf("%v", this.ScheduleUnix) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`NetworkErrorCode:` + fmt.Sprintf("%v", this.NetworkErrorCode) + `,`,
		`DeliveryHoursUtc:` + fmt.Sprintf("%v", this.DeliveryHoursUtc) + `,`,
		`ApplicationTag:` + fmt.Sprintf("%v", this.ApplicationTag) + `,`,
		`DeliveryCheckUpstream:` + fmt.Sprintf("%v", this.DeliveryCheckUpstream) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SMPPMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SMPPMessage{`,
		`SrcAddr:` + fmt.Sprintf("%v", this.SrcAddr) + `,`,
		`DestAddr:` + fmt.Sprintf("%v", this.DestAddr) + `,`,
		`ShortText:` + fmt.Sprintf("%v", this.ShortText) + `,`,
		`EsmClass:` + fmt.Sprintf("%v", this.EsmClass) + `,`,
		`DataCoding:` + fmt.Sprintf("%v", this.DataCoding) + `,`,
		`RegisteredDelivery:` + fmt.Sprintf("%v", this.RegisteredDelivery) + `,`,
		`ValidityPeriod:` + fmt.Sprintf("%v", this.ValidityPeriod) + `,`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`SrcAddrTon:` + fmt.Sprintf("%v", this.SrcAddrTon) + `,`,
		`SrcAddrNpi:` + fmt.Sprintf("%v", this.SrcAddrNpi) + `,`,
		`DestAddrTon:` + fmt.Sprintf("%v", this.DestAddrTon) + `,`,
		`DestAddrNpi:` + fmt.Sprintf("%v", this.DestAddrNpi) + `,`,
		`ProtocolId:` + fmt.Sprintf("%v", this.ProtocolId) + `,`,
		`PriorityFlag:` + fmt.Sprintf("%v", this.PriorityFlag) + `,`,
		`ReplaceIfPresentFlag:` + fmt.Sprintf("%v", this.ReplaceIfPresentFlag) + `,`,
		`SarMsgRefNum:` + fmt.Sprintf("%v", this.SarMsgRefNum) + `,`,
		`SarTotalSegments:` + fmt.Sprintf("%v", this.SarTotalSegments) + `,`,
		`SarSegmentSeqnum:` + fmt.Sprintf("%v", this.SarSegmentSeqnum) + `,`,
		`MoreMessagesToSend:` + fmt.Sprintf("%v", this.MoreMessagesToSend) + `,`,
		`PayloadType:` + fmt.Sprintf("%v", this.PayloadType) + `,`,
		`MessagePayload:` + fmt.Sprintf("%v", this.MessagePayload) + `,`,
		`UserMessageReference:` + fmt.Sprintf("%v", this.UserMessageReference) + `,`,
		`NetworkErrorCode:` + fmt.Sprintf("%v", this.NetworkErrorCode) + `,`,
		`ReceiptedMessageId:` + fmt.Sprintf("%v", this.ReceiptedMessageId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBendertalk(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBendertalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Debug = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sms = append(m.Sms, &SMSMessage{})
			if err := m.Sms[len(m.Sms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBendertalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBendertalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBendertalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ResponseStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Debug = append(m.Debug, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sms = append(m.Sms, &SMSMessage{})
			if err := m.Sms[len(m.Sms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBendertalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBendertalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMSMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBendertalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMSMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMSMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (SMPPMessagingMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidityUnix", wireType)
			}
			m.ValidityUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidityUnix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleUnix", wireType)
			}
			m.ScheduleUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduleUnix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (SMPPMessageState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkErrorCode", wireType)
			}
			m.NetworkErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryHoursUtc", wireType)
			}
			m.DeliveryHoursUtc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryHoursUtc |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCheckUpstream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliveryCheckUpstream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBendertalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBendertalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMPPMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBendertalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMPPMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMPPMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortText = append(m.ShortText[:0], dAtA[iNdEx:postIndex]...)
			if m.ShortText == nil {
				m.ShortText = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsmClass", wireType)
			}
			m.EsmClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EsmClass |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCoding", wireType)
			}
			m.DataCoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataCoding |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredDelivery", wireType)
			}
			m.RegisteredDelivery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredDelivery |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidityPeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidityPeriod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddrTon", wireType)
			}
			m.SrcAddrTon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcAddrTon |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddrNpi", wireType)
			}
			m.SrcAddrNpi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcAddrNpi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddrTon", wireType)
			}
			m.DestAddrTon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestAddrTon |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddrNpi", wireType)
			}
			m.DestAddrNpi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestAddrNpi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolId", wireType)
			}
			m.ProtocolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityFlag", wireType)
			}
			m.PriorityFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriorityFlag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceIfPresentFlag", wireType)
			}
			m.ReplaceIfPresentFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceIfPresentFlag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SarMsgRefNum", wireType)
			}
			m.SarMsgRefNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SarMsgRefNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SarTotalSegments", wireType)
			}
			m.SarTotalSegments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SarTotalSegments |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SarSegmentSeqnum", wireType)
			}
			m.SarSegmentSeqnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SarSegmentSeqnum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreMessagesToSend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MoreMessagesToSend = bool(v != 0)
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadType", wireType)
			}
			m.PayloadType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagePayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessagePayload = append(m.MessagePayload[:0], dAtA[iNdEx:postIndex]...)
			if m.MessagePayload == nil {
				m.MessagePayload = []byte{}
			}
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMessageReference", wireType)
			}
			m.UserMessageReference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserMessageReference |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkErrorCode", wireType)
			}
			m.NetworkErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptedMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBendertalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptedMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBendertalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBendertalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBendertalk(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBendertalk
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBendertalk
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBendertalk
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBendertalk
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBendertalk(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBendertalk = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBendertalk   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("bendertalk.proto", fileDescriptorBendertalk) }

var fileDescriptorBendertalk = []byte{
	// 1345 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xbf, 0x73, 0x1b, 0x45,
	0x14, 0xd6, 0x59, 0xb6, 0x25, 0x3d, 0x59, 0xf2, 0x65, 0xe3, 0xd8, 0x97, 0x1f, 0x56, 0x14, 0x03,
	0x13, 0xe1, 0x24, 0x0e, 0x71, 0x80, 0x2a, 0xc3, 0x4c, 0x70, 0x92, 0xc1, 0x85, 0x83, 0xe7, 0x24,
	0xd3, 0xde, 0xac, 0xef, 0x9e, 0xce, 0x87, 0x75, 0xbb, 0x97, 0xdd, 0x3d, 0xc7, 0xee, 0xf8, 0x13,
	0x68, 0xf8, 0x1f, 0xa8, 0xa8, 0xa9, 0x18, 0x86, 0x2a, 0x0d, 0x33, 0x29, 0x29, 0x63, 0xd1, 0x50,
	0xa6, 0xa0, 0xa0, 0x64, 0x76, 0x6f, 0xcf, 0xb6, 0x1c, 0x87, 0xa1, 0xbb, 0xfd, 0xbe, 0x6f, 0xdf,
	0xee, 0xfb, 0xde, 0xbb, 0xb7, 0xe0, 0xee, 0x22, 0x8b, 0x50, 0x28, 0x3a, 0xda, 0x5f, 0xcb, 0x04,
	0x57, 0x9c, 0xc0, 0x29, 0x72, 0xed, 0x5e, 0x9c, 0xa8, 0xbd, 0x7c, 0x77, 0x2d, 0xe4, 0xe9, 0xfd,
	0x98, 0xc7, 0xfc, 0xbe, 0x91, 0xec, 0xe6, 0x43, 0xb3, 0x32, 0x0b, 0xf3, 0x55, 0x6c, 0x5d, 0xf9,
	0xdb, 0x81, 0x9a, 0x8f, 0x2f, 0x72, 0x94, 0x8a, 0x78, 0x50, 0x3b, 0x40, 0x21, 0x13, 0xce, 0x3c,
	0xa7, 0xeb, 0xf4, 0x5a, 0x7e, 0xb9, 0x24, 0x6d, 0x98, 0x4a, 0x22, 0x6f, 0xaa, 0xeb, 0xf4, 0xa6,
	0xfd, 0xa9, 0x24, 0x22, 0x77, 0x60, 0x5a, 0x1d, 0x65, 0xe8, 0x55, 0xbb, 0x4e, 0xaf, 0xbd, 0xbe,
	0xb4, 0x76, 0xe6, 0x46, 0x36, 0xd8, 0xe0, 0x28, 0x43, 0xdf, 0x88, 0xc8, 0x2d, 0x98, 0xa3, 0x61,
	0x88, 0x52, 0x06, 0x8a, 0xef, 0x23, 0xf3, 0xa6, 0xbb, 0x4e, 0xaf, 0xe1, 0x37, 0x0b, 0x6c, 0xa0,
	0x21, 0xb2, 0x08, 0xb3, 0x0a, 0x19, 0x65, 0xca, 0x9b, 0x31, 0xa4, 0x5d, 0x91, 0x05, 0x98, 0x89,
	0x70, 0x37, 0x8f, 0xbd, 0xd9, 0xae, 0xd3, 0xab, 0xfb, 0xc5, 0x82, 0x2c, 0x41, 0x2d, 0x12, 0x47,
	0x81, 0xc8, 0x99, 0x57, 0x33, 0xf8, 0x6c, 0x24, 0x8e, 0xfc, 0x9c, 0x91, 0x1e, 0x54, 0x65, 0x2a,
	0xbd, 0x87, 0xdd, 0x6a, 0xaf, 0xb9, 0xbe, 0x78, 0xf6, 0x56, 0xfd, 0xad, 0xfe, 0x16, 0x4a, 0x49,
	0x63, 0xf4, 0xb5, 0x64, 0xe5, 0x77, 0x07, 0xea, 0x3e, 0xca, 0x8c, 0x33, 0x89, 0xff, 0x91, 0xf7,
	0x32, 0x80, 0x28, 0xf2, 0x09, 0x4e, 0xf2, 0x6f, 0x58, 0x64, 0x33, 0x22, 0xeb, 0x30, 0x2b, 0x15,
	0x55, 0xb9, 0xb4, 0x46, 0x5c, 0x9b, 0x34, 0xa2, 0x08, 0xdf, 0x37, 0x0a, 0xdf, 0x2a, 0x75, 0x4a,
	0x28, 0x04, 0x17, 0xd6, 0x86, 0x62, 0x71, 0x9a, 0xe8, 0x4c, 0xb7, 0xaa, 0xd1, 0x22, 0xd1, 0xff,
	0x9f, 0xcf, 0x6f, 0x55, 0x80, 0x53, 0xcc, 0xd6, 0xcb, 0x31, 0x27, 0xe8, 0x7a, 0x11, 0x98, 0x1e,
	0x0a, 0x9e, 0x9a, 0x0c, 0x1a, 0xbe, 0xf9, 0xd6, 0x1a, 0xc5, 0xcd, 0xc5, 0x1b, 0xfe, 0x94, 0xe2,
	0x5a, 0xa3, 0xf0, 0x50, 0xd9, 0x7b, 0x99, 0x6f, 0xf2, 0x00, 0xa6, 0x53, 0x1e, 0xa1, 0xa9, 0x4a,
	0x7b, 0x7d, 0x79, 0xf2, 0x06, 0xdb, 0xdb, 0xc5, 0x71, 0x09, 0x8b, 0xb7, 0x78, 0x84, 0xbe, 0x91,
	0x92, 0x0f, 0xa0, 0x75, 0x40, 0x47, 0x49, 0x94, 0xa8, 0xa3, 0x20, 0x67, 0xc9, 0xa1, 0x29, 0x5d,
	0xd5, 0x9f, 0x2b, 0xc1, 0x1d, 0x96, 0x1c, 0x6a, 0x91, 0x0c, 0xf7, 0x30, 0xca, 0x47, 0x58, 0x88,
	0x6a, 0x85, 0xa8, 0x04, 0x8d, 0x68, 0x1d, 0x66, 0xb4, 0x67, 0xe8, 0xd5, 0xcd, 0xe9, 0x37, 0x2e,
	0x3e, 0xdd, 0xf8, 0x8b, 0x7e, 0x21, 0x25, 0x77, 0x81, 0x30, 0x54, 0x2f, 0xb9, 0xd8, 0x0f, 0x8c,
	0xb1, 0x41, 0xa8, 0xaf, 0xdf, 0x30, 0x55, 0x75, 0x2d, 0xf3, 0x54, 0x13, 0x1b, 0xfa, 0xae, 0x77,
	0x81, 0x44, 0x38, 0x4a, 0x0e, 0x50, 0x1c, 0x05, 0x7b, 0x3c, 0x17, 0x32, 0xc8, 0x55, 0xe8, 0xb9,
	0x85, 0xba, 0x64, 0xbe, 0xd2, 0xc4, 0x8e, 0x0a, 0xc9, 0x6d, 0x98, 0xa7, 0x59, 0x36, 0x4a, 0x42,
	0xaa, 0x12, 0xce, 0x02, 0x45, 0x63, 0xef, 0x92, 0xf1, 0xaa, 0x7d, 0x06, 0x1e, 0xd0, 0x98, 0x7c,
	0x0e, 0x4b, 0x27, 0x61, 0xc3, 0x3d, 0x0c, 0xf7, 0x83, 0x3c, 0x93, 0x4a, 0x20, 0x4d, 0x3d, 0x62,
	0x36, 0x5c, 0x29, 0xe9, 0x0d, 0xcd, 0xee, 0x58, 0x72, 0xe5, 0xd7, 0x1a, 0x34, 0xcf, 0x24, 0x46,
	0xae, 0x42, 0x5d, 0x8a, 0x30, 0xa0, 0x51, 0x24, 0x6c, 0x2d, 0x6b, 0x52, 0x84, 0x8f, 0xa3, 0x48,
	0x90, 0xeb, 0xd0, 0x88, 0x74, 0x57, 0x1a, 0xae, 0xa8, 0x6a, 0x5d, 0x03, 0x86, 0x5c, 0x06, 0x90,
	0x7b, 0x5c, 0xa8, 0xc0, 0xd4, 0x53, 0x57, 0x78, 0xce, 0x6f, 0x18, 0x64, 0xa0, 0x8b, 0x7a, 0x1d,
	0x1a, 0x28, 0xd3, 0x20, 0x1c, 0x51, 0x29, 0x4d, 0x65, 0x5b, 0x7e, 0x1d, 0x65, 0xba, 0xa1, 0xd7,
	0xe4, 0x26, 0x34, 0x23, 0xaa, 0xa8, 0xf6, 0x2d, 0x61, 0xc5, 0x7f, 0xd7, 0xf2, 0x41, 0x43, 0x1b,
	0x06, 0x21, 0xf7, 0xe1, 0xb2, 0xc0, 0x38, 0x91, 0x0a, 0x05, 0x46, 0x41, 0x99, 0x88, 0x29, 0x60,
	0xcb, 0x27, 0xa7, 0xd4, 0x13, 0xcb, 0x68, 0xdb, 0x4e, 0x1a, 0x22, 0x43, 0x91, 0xf0, 0xc8, 0x14,
	0xb4, 0xe1, 0xb7, 0x4b, 0x78, 0xdb, 0xa0, 0x7a, 0x4e, 0x48, 0x14, 0x07, 0x49, 0x88, 0x81, 0x19,
	0x2e, 0x6e, 0x31, 0x27, 0x2c, 0xa6, 0x07, 0x0a, 0xe9, 0xc2, 0x5c, 0xe9, 0x48, 0xa0, 0x38, 0x33,
	0xfe, 0xb7, 0x7c, 0xb0, 0xae, 0x0c, 0x38, 0x9b, 0x50, 0xb0, 0x2c, 0x31, 0x86, 0x9f, 0x2a, 0x9e,
	0x67, 0x09, 0x59, 0x81, 0xd6, 0x89, 0x75, 0x26, 0xc8, 0x65, 0x23, 0x69, 0x96, 0xf6, 0xe9, 0x28,
	0x13, 0x1a, 0x1d, 0x66, 0x61, 0x52, 0xa3, 0xe3, 0xdc, 0x84, 0xa6, 0x19, 0xa1, 0x21, 0x1f, 0xe9,
	0xe1, 0x70, 0xa5, 0x38, 0xa8, 0x84, 0x36, 0x23, 0xdd, 0xe4, 0x99, 0x48, 0xb8, 0xd0, 0x89, 0x0f,
	0x47, 0x34, 0xf6, 0x16, 0x8d, 0x64, 0xae, 0x04, 0x9f, 0x8d, 0x68, 0x4c, 0x3e, 0x83, 0x25, 0x81,
	0xd9, 0x88, 0x86, 0x18, 0x24, 0xc3, 0x20, 0x13, 0x28, 0x91, 0xa9, 0x42, 0x7e, 0xd5, 0xc8, 0x17,
	0x2c, 0xbd, 0x39, 0xdc, 0x2e, 0x48, 0xb3, 0xed, 0x23, 0x98, 0x97, 0x54, 0x04, 0xa9, 0x8c, 0x03,
	0x81, 0xc3, 0x80, 0xe5, 0xa9, 0xd7, 0x2b, 0xa2, 0x4b, 0x2a, 0xb6, 0x64, 0xec, 0xe3, 0xf0, 0x79,
	0x9e, 0xea, 0x06, 0xd7, 0x32, 0xc5, 0x15, 0x1d, 0x05, 0x12, 0xe3, 0x14, 0x99, 0x92, 0xde, 0xc7,
	0x45, 0x83, 0x4b, 0x2a, 0x06, 0x9a, 0xe8, 0x5b, 0xbc, 0x54, 0x5b, 0x5d, 0x20, 0xf1, 0x85, 0x8e,
	0xbb, 0x7a, 0xa2, 0xb6, 0xc2, 0xbe, 0xc1, 0xc9, 0x03, 0xb8, 0x92, 0x72, 0x81, 0x41, 0x5a, 0x74,
	0xab, 0x9e, 0xee, 0x81, 0x44, 0x16, 0x79, 0x77, 0xcc, 0x4c, 0x26, 0x9a, 0xb4, 0x9d, 0x2c, 0x07,
	0xbc, 0x8f, 0xcc, 0x54, 0x38, 0xa3, 0x47, 0x23, 0x4e, 0xa3, 0xa2, 0xc2, 0x77, 0x0b, 0x57, 0x2d,
	0x66, 0x2a, 0x7c, 0x1b, 0xe6, 0x6d, 0xc0, 0xc0, 0xc2, 0xde, 0x3d, 0xd3, 0xc0, 0x6d, 0x0b, 0x6f,
	0x17, 0x28, 0xf9, 0x14, 0x16, 0x73, 0x89, 0xa2, 0x3c, 0x5e, 0xdb, 0x80, 0x02, 0x59, 0x88, 0xde,
	0x9a, 0x19, 0xd3, 0x0b, 0x9a, 0x2d, 0x67, 0x64, 0xc9, 0xbd, 0x67, 0x3e, 0x3c, 0x7a, 0xcf, 0x7c,
	0xf8, 0x04, 0x16, 0x04, 0x86, 0x98, 0x64, 0x0a, 0xa3, 0x93, 0x83, 0x92, 0xc8, 0xfb, 0xc2, 0x74,
	0x26, 0x39, 0xe1, 0xec, 0x31, 0x9b, 0xd1, 0xea, 0x87, 0xd0, 0x3c, 0xf3, 0x00, 0x92, 0x3a, 0x4c,
	0x6f, 0x27, 0x2c, 0x76, 0x2b, 0xa4, 0x09, 0x35, 0x6d, 0x41, 0x7f, 0xab, 0xef, 0x3a, 0xab, 0x3f,
	0x39, 0xd0, 0x9e, 0x7c, 0x1e, 0xc8, 0x1c, 0xd4, 0x8b, 0xaf, 0xaf, 0xf7, 0xdd, 0x0a, 0x99, 0x87,
	0x66, 0xb1, 0x32, 0x77, 0x71, 0x1d, 0x42, 0xa0, 0xbd, 0xc9, 0xcc, 0xff, 0xf2, 0x4d, 0xf1, 0x34,
	0xb9, 0x53, 0x5a, 0x64, 0x31, 0x7d, 0x96, 0x5b, 0x25, 0x2d, 0x68, 0x58, 0x60, 0x33, 0x72, 0xa7,
	0xc9, 0x25, 0x68, 0xd9, 0xe5, 0xf3, 0x3c, 0xdd, 0x45, 0xe1, 0x46, 0x67, 0xb7, 0xe0, 0xa1, 0x72,
	0x91, 0x2c, 0x80, 0x6b, 0x81, 0x7e, 0x12, 0x33, 0xaa, 0x72, 0x81, 0xee, 0xf0, 0xac, 0x2c, 0x49,
	0xd1, 0x8d, 0x57, 0x7f, 0x99, 0x02, 0xf7, 0xfc, 0xc8, 0x25, 0xd7, 0x61, 0xe9, 0x3c, 0xf6, 0x58,
	0x29, 0x4c, 0x33, 0xe5, 0x56, 0x2e, 0x22, 0x9f, 0x32, 0xc1, 0x73, 0x85, 0xae, 0x43, 0x96, 0xe1,
	0xea, 0x79, 0xd2, 0x8e, 0x0b, 0x8c, 0xdc, 0xa9, 0x0b, 0xf7, 0x1e, 0x66, 0x89, 0x26, 0xab, 0x17,
	0x91, 0x4f, 0x70, 0x84, 0x0a, 0x75, 0xca, 0xb7, 0x60, 0xf9, 0x3c, 0xb9, 0xc3, 0xec, 0x8c, 0xa2,
	0xbb, 0x23, 0x74, 0x67, 0xc8, 0x0d, 0xf0, 0xde, 0xb9, 0x75, 0x18, 0xa2, 0x2e, 0xa3, 0x3b, 0x7b,
	0x51, 0xf4, 0x1d, 0xb6, 0xcf, 0xf8, 0x4b, 0xe6, 0xd6, 0x2e, 0xda, 0xea, 0xe3, 0xb7, 0x18, 0xea,
	0xad, 0xf5, 0x8b, 0xb6, 0xf6, 0xf7, 0x93, 0x2c, 0xc3, 0xc8, 0x6d, 0xac, 0xfe, 0xe0, 0xc0, 0xa5,
	0x77, 0x5e, 0xcc, 0xc9, 0x80, 0x16, 0x7c, 0x82, 0x43, 0x9a, 0x8f, 0xb4, 0x85, 0x13, 0x2e, 0x95,
	0x2c, 0x55, 0x34, 0x16, 0x34, 0x75, 0x1d, 0xd2, 0x85, 0x1b, 0xef, 0xd0, 0x03, 0x41, 0x99, 0xa4,
	0xa1, 0x2a, 0x1a, 0x64, 0xc2, 0x0d, 0xab, 0xe8, 0x2b, 0x2e, 0xf0, 0x19, 0x17, 0x2f, 0xa9, 0x88,
	0xdc, 0xea, 0x97, 0x8f, 0x5e, 0x1d, 0x77, 0x2a, 0xaf, 0x8f, 0x3b, 0x95, 0x3f, 0x8e, 0x3b, 0x95,
	0x37, 0xc7, 0x1d, 0xe7, 0xed, 0x71, 0xc7, 0xf9, 0xe7, 0xb8, 0xe3, 0x7c, 0x37, 0xee, 0x38, 0x3f,
	0x8e, 0x3b, 0xce, 0xcf, 0xe3, 0x8e, 0xf3, 0x6a, 0xdc, 0x71, 0x5e, 0x8f, 0x3b, 0xce, 0x9b, 0x71,
	0xc7, 0xf9, 0x6b, 0xdc, 0xa9, 0xbc, 0x1d, 0x77, 0x9c, 0xef, 0xff, 0xec, 0x54, 0x76, 0x67, 0xcd,
	0xb4, 0x7b, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x30, 0x68, 0x77, 0xb2, 0x92, 0x0a, 0x00,
	0x00,
}
